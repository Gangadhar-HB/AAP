---
# Play 1: Build dynamic inventory from successful VMs
- hosts: localhost
  gather_facts: no
  vars:
    failed_vms: []
    successful_vms_final: "{{ successful_vms | default([]) }}"
  tasks:
    - name: Ensure we have successful VMs
      ansible.builtin.assert:
        that:
          - successful_vms_final | length > 0
        fail_msg: "No successful_vms found from previous playbook"
        success_msg: "Found {{ successful_vms_final | length }} successful VMs for post configuration."

    - name: Add each VM IP to dynamic inventory group
      ansible.builtin.add_host:
        name: "{{ item.ip_address }}"
        groups: new_vms
      loop: "{{ successful_vms_final }}"

# Play 2: Run Post Configuration on all new VMs in parallel
- hosts: new_vms
  gather_facts: no
  tasks:
    - name: Wait for SSH to be available
      ansible.builtin.wait_for_connection:
        delay: 10
        timeout: 300
      async: 300
      poll: 0
      register: ssh_wait_job

    - name: Run VM configuration scripts asynchronously
      ansible.builtin.shell: sudo find /root/logs/vm_config_thin_vol.sh/ -type f -name "script*" 2>/dev/null && sudo bash /root/logs/vm_config_thin_vol.sh/*
      async: 1800
      poll: 0
      register: vm_config_job
      ignore_errors: true

    - name: Wait for VM configuration scripts to complete
      ansible.builtin.async_status:
        jid: "{{ vm_config_job.ansible_job_id }}"
      register: vm_config_result
      until: vm_config_result.finished
      retries: 60
      delay: 30
      ignore_errors: true

    - name: Fail if ERRORs are found in logs
      ansible.builtin.shell: sudo grep -iE "ERROR" /root/logs/vm_config_thin_vol.sh/* || true
      register: vm_log_check
      failed_when: false

    - name: Fail if errors present
      ansible.builtin.fail:
        msg: "Found ERROR(s) on VM {{ inventory_hostname }}:\n{{ vm_log_check.stdout }}"
      when: vm_log_check.stdout != ""

