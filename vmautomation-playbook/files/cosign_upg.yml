- name: Main Cosign block with failure tracking
  block:
    - name: Check if {{default_yaml}} exists
      stat:
        path: "{{default_yaml}}"
      register: default_yaml_exists

    - name: Check if {{policy_json}} exists
      stat:
        path: "{{policy_json}}"
      register: policy_json_exists

    - name: Set initial JSON fact (empty if file doesn't exist)
      ansible.builtin.set_fact:
        registries_json: "{}"
        policy_json_content: >-
          {
            'default': [{'type': 'reject'}],
            'transports': {
              'docker': {
                '{{repo_url}}': [{
                  'type': 'sigstoreSigned',
                  'keyPath': '{{ pub_key_path }}/{{ cosign_pub_key_file | basename }}',
                  'signedIdentity': {'type': 'matchRepository'}
                }]
              },
              'containers-storage': {'': [{'type': 'insecureAcceptAnything'}]},
              'docker-archive': {'': [{'type': 'insecureAcceptAnything'}]},
              'docker-daemon': {'': [{'type': 'insecureAcceptAnything'}]}
            }
          }

    - name: Set initial JSON fact (empty if file doesn't exist)
      ansible.builtin.set_fact:
        # registries_json: "{}"
        registries_json: "{{ registries_json | combine({'docker': (registries_json.docker | default({})) | combine({repo_url: {'use-sigstore-attachments': true}})}) }}"
      when: not default_yaml_exists.stat.exists

    - block:
        - name: Read the content of the registries.d file (if it exists)
          ansible.builtin.slurp:
            path: "{{ default_yaml }}"
          register: registries_content
          ignore_errors: true  # Allow if the file doesn't exist
          
        - name: Set fact for parsed YAML content (as JSON)
          ansible.builtin.set_fact:
            registries_json: "{{ registries_content.content | b64decode | from_yaml }}"

        - name: Check if 'docker' section exists in JSON
          ansible.builtin.set_fact:
            docker_exists: "{{ registries_json.docker is defined }}"
          when: registries_json is defined

        - name: Add repository configuration to JSON if 'docker' exists
          ansible.builtin.set_fact:
            registries_json: "{{ registries_json | combine({'docker': registries_json.docker | combine({repo_url: {'use-sigstore-attachments': true}})}) }}"
          when: docker_exists

        - name: Add 'docker' section and repository configuration to JSON if 'docker' is missing
          ansible.builtin.set_fact:
            registries_json: "{{ registries_json | combine({'docker': {repo_url: {'use-sigstore-attachments': true}}}) }}"
          when: not docker_exists
      when: default_yaml_exists.stat.exists

    - name: Replace the entire YAML file with the JSON content
      copy:
        content: "{{ registries_json | to_nice_yaml }}"
        dest: "{{ default_yaml }}"
      when: registries_json is defined

    - name: Overwrite {{policy_json}}
      copy:
        dest: "{{ policy_json }}"
        content: "{{ policy_json_content | to_nice_json }}\n"
        mode: '0444' 


    - name: Copy the public key files
      ansible.builtin.copy:
        src: "{{cosign_pub_key_file}}"
        dest: "{{pub_key_path}}" 
        mode: '0444'

    - name: Copy the public key files again in /DGdata/Software for slave VMs
      ansible.builtin.copy:
        src: "{{cosign_pub_key_file}}"
        dest: "/DGdata/Software/"
        mode: '0444'

    
    
    - name: Mark Pass VM in localhost file
      local_action:
        module: lineinfile
        path: "{{ cosign_failed_vms}}"
        line: "{{ inventory_hostname }}:1:{{cosign_role}}:Passed"
        create: yes
      delegate_to: localhost
      run_once: false

  rescue:
    - name: Mark failed VM in localhost file
      local_action:
        module: lineinfile
        path: "{{ cosign_failed_vms}}"
        line: "{{ inventory_hostname }}:1:{{cosign_role}}:Failed"
        create: yes
      delegate_to: localhost
      run_once: false

